{"mappings":"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","sources":["sketch.js"],"sourcesContent":["//-----------------------------------------------------------------------------\n// name: sketch.js\n// date: March 2025\n// desc: This the processing.js code that runs in the browser and sends messages to the server.js code running locally\n// usage: npm run start to serve the browser code\n// This can be run from server (eg. aws, etc.) deployed online or locally -- but the server.js code must be run locally\n//-----------------------------------------------------------------------------\n\nlet capture; //capture object representing webcam\nlet target_hue; //target color\nlet target_color = 255; //rgb of target\nlet targetIndex = 7; //default index for white -- not using in a substantial way\n\n//hsv_colors -- ranges of the values for each color classification\nlet redHSV = [0, 60];\nlet yellowHSV = [61, 120];\nlet greenHSV = [121, 180];\nlet cyanHSV = [181, 240];\nlet blueHSV = [241, 300];\nlet magentaHSV = [301, 360];\nlet blackThresh = 20;\nlet whiteThresh = 85;\n\n//color definitions and thresholds for black, white, and grey which use saturation and brightness\nlet colorDefs = [redHSV, yellowHSV, greenHSV, cyanHSV, blueHSV, magentaHSV ];\nvar colorNames = [\"red\", \"yellow\", \"green\", \"cyan\", \"blue\", \"magenta\", \"black\", \"white\", \"grey\" ];\nlet colorThresh = 15;\nlet brightThresh = 30;\nlet satThresh = 30;\n\n//an array that holds the color counts for each color classification\nlet colorCounts;\n\nlet usingNamedColor = false; //if true, use the named color for the target color but not really needed anymore\nlet targetCount = 0; //the target color count -- the target is special as it is much narrower range of the color space that the user chooses\n\n//setup the canvas and the video capture\nfunction setup() {\n  createCanvas(500, 500);\n\n  // Create the video capture and hide the element.\n  capture = createCapture(VIDEO);\n  capture.hide();\n\n  describe('Color detection.');\n  pixelDensity(1);\n}\n\n//draw the video capture and apply a blur filter to the image and call detect to find the colors in the image and send the OSC\nfunction draw() {\n  // Draw the video capture within the canvas.\n  image(capture, 0, 0, width, width * capture.height / capture.width);\n  filter(BLUR, 3, true);\n  detect();\n  fill(target_color);\n  rect( 25, 25, 25, 25 );\n}\n\n//calls the server to send the color information to the OSC server using fetch()\nfunction sendColorOSCInfo()\n{\n  let percentTarget = targetCount / (width * height); //finds the percentage of the target color in the image\n  let url = `http://localhost:3001/colorDetect?targetPercent=${percentTarget}`; //adds the target percent to the url\n  for(let i=0; i<colorCounts.length; i++)\n  {\n    url += `&${colorNames[i]}=${colorCounts[i]/(width * height)}`; //adds the percent of each color to the url\n  }\n  fetch(url); //calls the server using fetch\n  // console.log(url); //uncomment to see the url in the console\n}\n\n//detects the colors in the image and changes the color of the pixels that match the target color, also sends the color information to the server via sendColorOSCInfo()\nfunction detect()\n{\n  loadPixels(); //load current screen into pixel array\n  colorCounts = [0, 0, 0, 0, 0, 0, 0, 0, 0]; //init counts to have 0 for each color\n  targetCount =0; //init target count to 0\n\n\n  //for each pixel, add to the colorCounts array the correct classification of the color & to the target count.\n  for ( let i=0; i<width; i++ )\n\n  {\n    for ( let j=0; j<height; j++ )\n    {\n      //gets the color information of each pixel\n      let loc = (i + width * j) * 4;\n      let curColor = color( pixels[loc], pixels[loc+1], pixels[loc+2], pixels[loc+3]);\n      let cur = hue(curColor); //hue of the color\n      let bright = brightness(curColor); //brightness of the color\n      let satur = saturation(curColor); //saturation of the color\n\n      let which = classifyColor(cur, bright, satur); //classifies the color based on hue, brightness, and saturation\n      colorCounts[which]++; //adds to the color count for the classification\n      \n      //adds to the target count if the color is the target color (within a threshold)\n      if( (which == targetIndex && usingNamedColor) || \n      (( cur < hue(target_color)+colorThresh && cur > hue(target_color)-colorThresh    ) &&\n       ( bright < brightness(target_color)+brightThresh && bright > brightness(target_color)-brightThresh    ) &&\n       ( satur < saturation(target_color)+satThresh && satur > saturation(target_color)-satThresh    )\n      ))\n      {\n        //255, 105, 180 - hot pink\n        pixels[loc] = 255; \n        pixels[loc + 1] = 105;\n        pixels[loc + 2] = 180;\n        targetCount++;\n      }\n    }\n  }\n  updatePixels(); //changes the pixels on screen\n  sendColorOSCInfo(); //sends the color information to the server to send to the OSC elsewhere so we can receive in Chuck or Max or what have you\n}\n\n//classifies the color based on hue, brightness, and saturation\nfunction classifyColor(cur, bright, sat)\n{\n  let which = -1; //which color classification index (into the colorNames array)\n  let index = 0; //for use when checking for the colors based on hues in the while loop below\n\n  if ( bright < blackThresh && sat < 30 ) //black\n  {\n    which = 6;\n  } \n  else if ( bright > whiteThresh ) //white\n  {\n    which = 7;\n  } \n  else if( sat < 20 ) //grey\n  {\n    which = 8; \n  }\n  else\n  {\n    while ( which == -1 ) //if not black, white, or grey, check the hues of the colors\n    {\n      if ( cur <= colorDefs[index][1] )\n      {\n        which = index;\n      }\n      index++;\n    }\n  }\n  return which; //return which index of the colorNames array the color is classified as\n}\n\n//prints the color information to the console -- all the % that each color is in the image including target percent\nfunction printColorInfo(colorCounts)\n{\n  //this sorts the colors by the number of pixels in the image that are that color -- not used now but could be useful\n  let colorIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  colorIndices.sort(function(a, b) {\n    return colorCounts[b]-colorCounts[a]\n  });\n\n  //prints all the current color % to the console incl. target color\n  print( \"========= Color Info =============\" );\n  for (let i =0; i<colorCounts.length; i++)\n  {\n    let index = colorIndices[i];\n    print(colorNames[index] + \": \" + colorCounts[index] + \" percent of image:\" + (colorCounts[index] / (width * height)));\n  }\n  print(\"TARGET COLOR (more specific): Number of pixels with target color: \" + targetCount+ \" percent of image:\" + (targetCount / (width * height)));\n  print( \"=================\" );\n}\n\n//when the mouse is clicked, get/change the target color and print those color details to the console\nfunction mouseClicked()\n{\n  loadPixels();\n  let index = (mouseX + width * mouseY) * 4;\n  target_color = color( pixels[index], pixels[index+1], pixels[index+2], pixels[index+3] );\n  target_hue = hue(target_color);\n  let satur = saturation(target_color);\n\n  \n  print( \"Target color is: \" + red(target_color) + \",\" + green(target_color) + \",\" + blue(target_color) );\n  print( \"Target hue is: \" + target_hue );\n  print (\"Target brightness is: \" + brightness(target_color));\n  print (\"Target saturation is: \" + satur);\n\n  targetIndex = classifyColor(target_hue, brightness(target_color), satur);\n  print(\"Named color:\" + colorNames[targetIndex] + \", \" +targetIndex);\n}\n\n//when a key is pressed, print the color information to the console or you can change the color thresholds to make wider to narrow the color classification\nfunction keyPressed()\n{\n  if(key == ' ')\n  {\n    printColorInfo(colorCounts); //print the color information to the console\n  }\n  else if(key == 'q')\n  {\n    colorThresh++; //increase the target color threshold (allow a wider range of colors to be considered the target color)\n    print(\"Color thresh is:\" + colorThresh); \n  }\n  else if(key == 'a')\n  {\n    colorThresh--; //decrease the target color threshold (allow a smaller range of colors to be considered the target color)\n    print(\"Color thresh is:\" + colorThresh);\n  }\n  \n}\n"],"names":[],"version":3,"file":"p5ColorDetectionAndOSC.ba7f5425.js.map","sourceRoot":"/__parcel_source_root/"}